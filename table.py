import csvimport itertoolsimport refrom enum import Enumfrom typing import List, Dict, Anyimport datetime as DTimport cProfileclass DataSet:    def __init__(self, file_name: str, job:str):        self.file_name = file_name        self.vacancies_objects = [Vacancy(vac) for vac in self.csv_reader(self.file_name)]    @staticmethod    def clean_html(raw_html: str) -> str:        return ' '.join(re.sub(re.compile('<.*?>'), '', raw_html).replace('\n', ';').split())    @staticmethod    def csv_reader(file_name: str) -> (List[str], List[List[str]]):        with open(file_name, 'r', encoding="utf-8-sig") as csvfile:            csvreader = csv.reader(csvfile)            data = []            titles = csvreader.__next__()            inputconnect = InputConect()            for vac in csvreader:                dic = {}                vac = list(filter(lambda x: x != '', vac))                if len(vac) == len(titles):                    for i in range(len(vac)):                        dic[titles[i]] = vac[i]                    data.append(dic)                    inputconnect.count(Vacancy(dic), job)            inputconnect.print()            return dataclass Salary:    def __init__(self, salary_from, salary_to, salary_currency):        self.salary_from = salary_from        self.salary_to = salary_to        self.salary_currency = salary_currencyclass Vacancy:    def __init__(self, dic_vac):        self.name = dic_vac['name']        self.salary = Salary(dic_vac['salary_from'], dic_vac['salary_to'], dic_vac['salary_currency'])        self.area_name = dic_vac['area_name']        self.published_at = dic_vac['published_at']    def __iter__(self):        self.row = {'name': self.name,                    'salary_from': self.salary,                    'area_name': self.area_name,                    'published_at': self.published_at, }        return iter(self.row)    def __getitem__(self, item):        self.row = {'name': self.name,                    'salary_from': self.salary,                    'area_name': self.area_name,                    'published_at': self.published_at, }        return self.row[item]class InputConect:    def __init__(self):        self.years_sal_all = {}        self.years_count_all = {}        self.years_sal_job = {}        self.years_count_job = {}        self.city_sal = {}        self.city_percent = {}    def count(self,vac: Vacancy, job:str):        self.years_sal_all = self.years_info_sal_all(vac,self.years_sal_all)        self.years_count_all = self.years_info_count_all(vac, self.years_count_all)        self.years_sal_job = self.years_info_sal_job(vac, job, self.years_sal_job)        self.years_count_job = self.years_info_count_job(vac, job,self.years_count_job)        self.city_sal = self.city_info_sal(vac,self.city_sal)        self.city_percent = self.city_info_percent(vac,self.city_percent)    def print(self):        self.sorting()        print('Динамика уровня зарплат по годам: '+ str(self.get_avg_val(self.years_sal_all, self.years_count_all)))        print('Динамика количества вакансий по годам: ' + str(self.years_count_all))        print('Динамика уровня зарплат по годам для выбранной профессии: ' + str(self.get_avg_val(self.years_sal_job, self.years_count_job)))        print('Динамика количества вакансий по годам для выбранной профессии: ' + str(self.years_count_job))        print('Уровень зарплат по городам (в порядке убывания): ' + str(self.city_sal))        print('Доля вакансий по городам (в порядке убывания): ' + str(self.city_percent))    def sorting(self):        self.city_sal = self.get_avg_val(self.city_sal,self.city_percent)        total_cities = 0        for key,value in self.city_percent.items():            total_cities += value        self.city_percent = self.get_avg_count(self.city_percent,total_cities)        for key,value in self.city_sal.copy().items():            if not self.city_percent.keys().__contains__(key):                self.city_sal.pop(key)        self.city_sal = dict(sorted(self.city_sal.items(), key=lambda x: x[1], reverse=True))        self.city_percent = dict(sorted(self.city_percent.items(), key=lambda x: x[1], reverse=True))        self.city_sal = dict(itertools.islice(self.city_sal.items(),10))        self.city_percent = dict(itertools.islice(self.city_percent.items(),10))    def years_info_sal_all(self,vac:Vacancy, years_sal: Dict):        if years_sal.keys().__contains__(self.get_correct_data(vac.published_at)):            years_sal[self.get_correct_data(vac.published_at)] += self.sort_money(vac)        else:            years_sal[self.get_correct_data(vac.published_at)] = self.sort_money(vac)        return years_sal    def years_info_sal_job(self,vac:Vacancy, job:str, years_sal: Dict):        if job in vac.name:            if years_sal.keys().__contains__(self.get_correct_data(vac.published_at)):                years_sal[self.get_correct_data(vac.published_at)] += self.sort_money(vac)            else:                years_sal[self.get_correct_data(vac.published_at)] = self.sort_money(vac)        else:            if not years_sal.keys().__contains__(self.get_correct_data(vac.published_at)):                years_sal[self.get_correct_data(vac.published_at)] = 0        return years_sal    def years_info_count_all(self,vac:Vacancy, years_count: Dict):        if years_count.keys().__contains__(self.get_correct_data(vac.published_at)):            years_count[self.get_correct_data(vac.published_at)] += 1        else:            years_count[self.get_correct_data(vac.published_at)] = 1        return years_count    def years_info_count_job(self,vac:Vacancy, job:str, years_count: Dict):        if job in vac.name:            if years_count.keys().__contains__(self.get_correct_data(vac.published_at)):                years_count[self.get_correct_data(vac.published_at)] += 1            else:                years_count[self.get_correct_data(vac.published_at)] = 1        else:            if not years_count.keys().__contains__(self.get_correct_data(vac.published_at)):                years_count[self.get_correct_data(vac.published_at)] = 0        return years_count    def city_info_sal(self,vac:Vacancy,city_sal):        if city_sal.keys().__contains__(vac.area_name):            city_sal[vac.area_name] += self.sort_money(vac)        else:            city_sal[vac.area_name] = self.sort_money(vac)        return city_sal    def city_info_percent(self, vac:Vacancy, city_percent: Dict):        if city_percent.keys().__contains__(vac.area_name):            city_percent[vac.area_name] += 1        else:            city_percent[vac.area_name] = 1        return city_percent    def get_avg_val(self,dic_sal:Dict,dic_count:Dict):        for key in dic_sal:            if dic_count[key]!=0:                dic_sal[key] = int(dic_sal[key]/dic_count[key])        return dic_sal    def get_avg_count(self,dic_sal:Dict,count : int):        for key in dic_sal.copy():            dic_sal[key] = dic_sal[key]/count            if dic_sal[key] <= 0.01:                dic_sal.pop(key)            if dic_sal.__contains__(key):                dic_sal[key] = round(dic_sal[key],4)        return dic_sal    def get_correct_data(self, date:str):        return int(date[0:4])    def sort_money(self, vac: Vacancy):        salary_from = int(vac.salary.salary_from.split('.')[0])        salary_to = int(vac.salary.salary_to.split('.')[0])        return (salary_from + salary_to) / 2 * currency_to_rub[vac.salary.salary_currency]class Translate(Enum):    name = 'Название'    description = 'Описание'    key_skills = 'Навыки'    experience_id = 'Опыт работы'    premium = 'Премиум-вакансия'    employer_name = 'Компания'    salary_from = 'Оклад'    salary_to = 'Верхняя граница вилки оклада'    salary_gross = 'Оклад указан до вычета налогов'    salary_currency = 'Идентификатор валюты оклада'    area_name = 'Название региона'    published_at = 'Дата публикации вакансии'    AZN = "Манаты"    BYR = "Белорусские рубли"    EUR = "Евро"    GEL = "Грузинский лари"    KGS = "Киргизский сом"    KZT = "Тенге"    RUR = "Рубли"    UAH = "Гривны"    USD = "Доллары"    UZS = "Узбекский сум"    noExperience = "Нет опыта"    between1And3 = "От 1 года до 3 лет"    between3And6 = "От 3 до 6 лет"    moreThan6 = "Более 6 лет"currency_to_rub = {    "AZN": 35.68,    "BYR": 23.91,    "EUR": 59.90,    "GEL": 21.74,    "KGS": 0.76,    "KZT": 0.13,    "RUR": 1,    "UAH": 1.64,    "USD": 60.66,    "UZS": 0.0055,}translate_yes_no = {    'да': True,    'нет': False,    'true': 'Да',    'false': 'Нет',}file_name = input('Введите название файла: ')job = input('Введите название профессии: ')dataset = DataSet(file_name,job)